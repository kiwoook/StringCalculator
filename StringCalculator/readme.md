프로그램 동작 순서는 다음과 같다.

1. 받은 계산식 문자열 앞, 뒤에 공백을 넣어 향후 발생한 에러를 대비한다.

2. 반복문을 통해 기호가 얼마나 있는지 개수를 체크한다. 기호의 개수를 symbol이라 정한다.

3. 무한 반복문 진입
4. 문자열안에 곱셈, 나눗셈 연산이 있는지 확인한다. 있으면 1, 없으면 0 인덱스는 i를 사용한다. 해당 인덱스(i)는 곱셈이거나 나눗셈이다.<br>
  4-1. 1인 상태에서는 곱셈과 나눗셈 연산 조건문에만 진입한다. 0인 상태에서는 덧셈과 뺄셈 조건문에만 진입한다. <br>
    4-1-1. 기호(i)를 기준으로 앞으로 인접한 숫자로 적힌 문자를 추출한다. <br>
    4-1-2. 반복문을 통해 '0'과 '9'사이가 아니면 해당 index를 k로 정의하고 break를 통해 반복문을 탈출한다. k는 현재 연산과 관련없는 기호거나 공백이다. <br>
    4-1-3. 해당 위치를 추출해낸다. **k+1(기호 다음 인덱스 즉, 숫자 문자열)부터 i-1(현재 연산 기호 이전 인덱스)까지 추출하여 문자열이 아닌 숫자로 바꾼다.** <br>
	4-1-4. 기호(i)를 기준으로 뒤로 인접한 숫자로 적힌 문자를 추출한다. <br>
    4-1-5. 반복문을 통해 '0'과 '9'사이가 아니면 해당 index를 j로 정의하고 break를 통해 반복문을 탈출한다. j는 현재 연산과 관련없는 기호거나 공백이다. <br>
    4-1-6. 해당 위치를 추출해낸다. **i+1(현재 연산 기호 이후 인덱스)부터 j-1(기호 이전 인덱스)까지 추출하여 문자열이 아닌 숫자로 바꾼다.** <br>		
		4-1-7. 인접한 두 숫자를 i의 맞는 기호로 연산하고 해당 숫자를 문자열로 전환한다. <br>
		4-1-8. i와 인접했던 숫자 문자열과 i를 삭제하고 해당 문자열을 삽입한다. 그리고 symbol에서 1을 뺀다. <br>
5. symbol값이 0이되면 더 이상 연산 기호가 존재하지 않다와 같으므로 무한반복문을 종료한다.
6. 앞과 뒤의 공백을 삭제한다.
7. 출력한다.
  
<hr>

***공백을 넣은 이유***<br><br>
숫자 문자열을 추출할때 만약 공백을 넣지 않는다면 해당 문자열 맨앞과 맨뒤에서 오류가 발생한다.<br> 0 왼쪽이나 문자열 맨뒤 오른쪽으로는 아무런 값이 없기 때문에 해당 반복문을 종료시켜야 하는데 이때 4-1-3, 4-1-6에서는 k+1과 j-1까지 추출한다 정의하였다.<br> 그렇다면 숫자형 문자열이 버려지는 일이 발생하게 된다. 이는 연산을 하는데 큰 문제가 발생하므로 앞 뒤에 공백을 넣어 해당 오류가 발생하지 않도록 막는다.
